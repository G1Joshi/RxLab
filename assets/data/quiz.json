{
  "quiz": [
    {
      "type": "multiple_choice",
      "category": "Basics",
      "difficulty": "easy",
      "points": 10,
      "question": "Which operator transforms each emitted value?",
      "options": ["filter", "map", "take", "merge"],
      "correctIndex": 1,
      "explanation": "map applies a function to each value, transforming it into something new."
    },
    {
      "type": "multiple_choice",
      "category": "Basics",
      "difficulty": "easy",
      "points": 10,
      "question": "What does filter do?",
      "options": [
        "Transforms values",
        "Removes values that don't match condition",
        "Combines streams",
        "Delays values"
      ],
      "correctIndex": 1,
      "explanation": "filter (or where) keeps only values that pass the predicate test."
    },
    {
      "type": "multiple_choice",
      "category": "Basics",
      "difficulty": "easy",
      "points": 10,
      "question": "take(3) will:",
      "options": [
        "Skip 3 items",
        "Emit first 3 items then complete",
        "Take every 3rd item",
        "Wait 3 seconds"
      ],
      "correctIndex": 1,
      "explanation": "take(n) emits the first n items and then completes the stream."
    },
    {
      "type": "multiple_choice",
      "category": "Basics",
      "difficulty": "easy",
      "points": 10,
      "question": "What happens if you don't dispose a subscription?",
      "options": [
        "Nothing",
        "Memory leak",
        "Faster performance",
        "Automatic cleanup"
      ],
      "correctIndex": 1,
      "explanation": "Undisposed subscriptions hold references and cause memory leaks."
    },
    {
      "type": "multiple_choice",
      "category": "Basics",
      "difficulty": "easy",
      "points": 10,
      "question": "merge() combines streams by:",
      "options": [
        "Pairing by index",
        "Interleaving emissions as they arrive",
        "Sequential order",
        "Taking latest only"
      ],
      "correctIndex": 1,
      "explanation": "merge interleaves emissions from all streams as they arrive."
    },
    {
      "type": "multiple_choice",
      "category": "Operators",
      "difficulty": "medium",
      "points": 15,
      "question": "Which operator waits for a pause in emissions?",
      "options": ["throttle", "debounce", "delay", "sample"],
      "correctIndex": 1,
      "explanation": "debounce waits for quiet period. throttle rate-limits. delay shifts all."
    },
    {
      "type": "multiple_choice",
      "category": "Operators",
      "difficulty": "medium",
      "points": 15,
      "question": "combineLatest vs zip - the key difference is:",
      "options": [
        "combineLatest is faster",
        "zip emits on any source, combineLatest pairs by index",
        "combineLatest emits on any source, zip pairs by index",
        "They are identical"
      ],
      "correctIndex": 2,
      "explanation": "combineLatest emits when ANY stream emits. zip pairs values by index position."
    },
    {
      "type": "multiple_choice",
      "category": "Subjects",
      "difficulty": "medium",
      "points": 15,
      "question": "BehaviorSubject differs from PublishSubject by:",
      "options": [
        "Being slower",
        "Replaying the latest value to new subscribers",
        "Not allowing errors",
        "Buffering all values"
      ],
      "correctIndex": 1,
      "explanation": "BehaviorSubject replays its current/latest value to new subscribers."
    },
    {
      "type": "multiple_choice",
      "category": "Operators",
      "difficulty": "medium",
      "points": 15,
      "question": "scan differs from reduce by:",
      "options": [
        "scan is faster",
        "scan emits each intermediate value, reduce only final",
        "reduce is for numbers only",
        "They are identical"
      ],
      "correctIndex": 1,
      "explanation": "scan emits after each value. reduce waits for completion."
    },
    {
      "type": "multiple_choice",
      "category": "Concepts",
      "difficulty": "medium",
      "points": 15,
      "question": "A 'Cold' Observable:",
      "options": [
        "Shares values between subscribers",
        "Creates new producer per subscriber",
        "Is faster than Hot",
        "Never completes"
      ],
      "correctIndex": 1,
      "explanation": "Cold creates new producer per subscription (like Netflix). Hot shares (like live TV)."
    },
    {
      "type": "predict_output",
      "category": "Operators",
      "difficulty": "easy",
      "points": 15,
      "question": "What is the output?",
      "input": "[1, 2, 3]",
      "operator": "map(x => x * 2)",
      "options": ["[2, 4, 6]", "[1, 2, 3, 1, 2, 3]", "[1, 4, 9]", "[3, 6, 9]"],
      "correctIndex": 0,
      "explanation": "map transforms each value: 1*2=2, 2*2=4, 3*2=6"
    },
    {
      "type": "predict_output",
      "category": "Operators",
      "difficulty": "easy",
      "points": 15,
      "question": "What values pass through?",
      "input": "[1, 2, 3, 4, 5]",
      "operator": "filter(x => x > 2)",
      "options": ["[3, 4, 5]", "[1, 2]", "[2, 3, 4, 5]", "[1, 2, 3]"],
      "correctIndex": 0,
      "explanation": "filter keeps values where predicate is true: 3>2, 4>2, 5>2"
    },
    {
      "type": "predict_output",
      "category": "Operators",
      "difficulty": "medium",
      "points": 20,
      "question": "What does scan emit?",
      "input": "[1, 2, 3]",
      "operator": "scan((acc, x) => acc + x, 0)",
      "options": ["[1, 3, 6]", "[6]", "[0, 1, 3, 6]", "[1, 2, 3]"],
      "correctIndex": 0,
      "explanation": "scan emits running totals: 0+1=1, 1+2=3, 3+3=6"
    },
    {
      "type": "predict_output",
      "category": "Combination",
      "difficulty": "medium",
      "points": 20,
      "question": "What does zip produce?",
      "input": "A:[1,2,3] B:[X,Y]",
      "operator": "zip(A, B)",
      "options": [
        "[(1,X), (2,Y)]",
        "[(1,X), (2,Y), (3,?)]",
        "[1,2,3,X,Y]",
        "[(1,X,Y), (2,X,Y)]"
      ],
      "correctIndex": 0,
      "explanation": "zip pairs by index. Only 2 pairs since B has 2 values."
    },
    {
      "type": "predict_output",
      "category": "Combination",
      "difficulty": "hard",
      "points": 25,
      "question": "A emits 1, B emits X, A emits 2. Output?",
      "input": "A:1, B:X, A:2",
      "operator": "combineLatest(A, B)",
      "options": ["(1,X), (2,X)", "(1,X)", "(2,X)", "(1,X), (1,X), (2,X)"],
      "correctIndex": 0,
      "explanation": "combineLatest emits when ANY source emits (once all have value)."
    },
    {
      "type": "predict_output",
      "category": "Operators",
      "difficulty": "hard",
      "points": 25,
      "question": "User types H-e-l-l-o rapidly, pauses 500ms. What emits?",
      "input": "H, e, l, l, o (rapid), [pause 500ms]",
      "operator": "debounce(300ms)",
      "options": [
        "Hello (after pause)",
        "H, e, l, l, o",
        "H, Hello",
        "Nothing"
      ],
      "correctIndex": 0,
      "explanation": "debounce waits for quiet period. Emits 'Hello' after 300ms silence."
    },
    {
      "type": "find_bug",
      "category": "Practical",
      "difficulty": "hard",
      "points": 25,
      "question": "This search has a bug. Why might results be wrong?",
      "code": "searchText\n  .flatMap(q => searchApi(q))\n  .subscribe(showResults)",
      "options": [
        "flatMap doesn't cancel previous searches",
        "Missing debounce",
        "searchApi is wrong",
        "No error handling"
      ],
      "correctIndex": 0,
      "explanation": "flatMap keeps ALL subscriptions. Old slow searches may override new. Use switchMap!"
    },
    {
      "type": "find_bug",
      "category": "Practical",
      "difficulty": "hard",
      "points": 25,
      "question": "This component has a memory leak. What's the bug?",
      "code": "class MyComponent {\n  init() {\n    stream.subscribe(data => {\n      this.updateUI(data)\n    })\n  }\n}",
      "options": [
        "Subscription never disposed",
        "stream is null",
        "updateUI is wrong",
        "Missing error handler"
      ],
      "correctIndex": 0,
      "explanation": "Subscriptions must be disposed when component is destroyed!"
    },
    {
      "type": "multiple_choice",
      "category": "Practical",
      "difficulty": "hard",
      "points": 20,
      "question": "For search-as-you-type, the best combination is:",
      "options": [
        "map + filter",
        "debounce + switchMap",
        "take + merge",
        "delay + concat"
      ],
      "correctIndex": 1,
      "explanation": "debounce waits for typing pause, switchMap cancels previous search."
    },
    {
      "type": "multiple_choice",
      "category": "Practical",
      "difficulty": "hard",
      "points": 20,
      "question": "share() transforms a Cold Observable by:",
      "options": [
        "Making it faster",
        "Multicasting to share emissions",
        "Adding error handling",
        "Buffering values"
      ],
      "correctIndex": 1,
      "explanation": "share makes Cold Observable Hot, sharing subscription among observers."
    },
    {
      "type": "multiple_choice",
      "category": "Practical",
      "difficulty": "hard",
      "points": 25,
      "question": "Which operator is best for a 'Save' button to prevent double-submits while a request is pending?",
      "options": ["flatMap", "switchMap", "exhaustMap", "concatMap"],
      "correctIndex": 2,
      "explanation": "exhaustMap ignores new values while the inner observable is active, perfect for preventing rapid double-clicks."
    },
    {
      "type": "predict_output",
      "category": "Combination",
      "difficulty": "hard",
      "points": 25,
      "question": "A emits [1, 2], B emits [A, B]. What does A.withLatestFrom(B) produce if A emits 1, then B emits A, then B emits B, then A emits 2?",
      "options": [
        "[ (2, B) ]",
        "[ (1, A), (2, B) ]",
        "[ (1, B), (2, B) ]",
        "[ (2, A) ]"
      ],
      "correctIndex": 0,
      "explanation": "withLatestFrom only emits when the SOURCE (A) emits. At t=1, A emits but B has no value yet. At t=4, A emits 2 and B's latest is B."
    },
    {
      "type": "multiple_choice",
      "category": "Theory",
      "difficulty": "hard",
      "points": 30,
      "question": "In Rx, 'Lifting' refers to:",
      "options": [
        "Increasing performance",
        "The process of creating a new Observable that wraps another",
        "Converting Hot to Cold",
        "Handling errors at the root"
      ],
      "correctIndex": 1,
      "explanation": "Lifting is the fundamental mechanism where an operator 'lifts' the Observer of the new Observable into the source Observable."
    },
    {
      "type": "find_bug",
      "category": "Advanced",
      "difficulty": "hard",
      "points": 30,
      "question": "Why is this retry logic potentially dangerous?",
      "code": "observable.retryWhen(errors => errors.delay(100ms))",
      "options": [
        "It might retry forever if the error persists",
        "Delay is too short",
        "Errors stream will complete",
        "Missing take(5)"
      ],
      "correctIndex": 0,
      "explanation": "Without a limit (like take(n) or scan to count attempts), retryWhen will create an infinite loop of retries if the error is permanent."
    },
    {
      "type": "multiple_choice",
      "category": "Concepts",
      "difficulty": "hard",
      "points": 25,
      "question": "The main advantage of 'shareReplay(1)' over 'share()' is:",
      "options": [
        "It's faster",
        "It caches the last value for late subscribers",
        "It handles errors better",
        "It works with Cold observables"
      ],
      "correctIndex": 1,
      "explanation": "shareReplay(1) not only shares the subscription but also replays the last value so late subscribers don't have to wait for the next emission."
    }
  ]
}
