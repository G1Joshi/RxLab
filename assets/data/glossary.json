{
  "glossary": [
    {
      "term": "Observable",
      "definition": "A push-based, lazy collection that emits values over time. The fundamental building block of reactive programming.",
      "category": "Core",
      "relatedTerms": ["Observer", "Subscription", "Stream"],
      "example": "Observable.interval(1.second) emits 0, 1, 2, 3..."
    },
    {
      "term": "Observer",
      "definition": "An object that receives values from an Observable through onNext, onError, and onComplete callbacks.",
      "category": "Core",
      "relatedTerms": ["Observable", "Subscription"],
      "example": "observer.onNext(value), observer.onError(err), observer.onComplete()"
    },
    {
      "term": "Subscription",
      "definition": "Represents the connection between an Observable and Observer. Can be disposed to cancel.",
      "category": "Core",
      "relatedTerms": ["Observable", "Observer", "Dispose"],
      "example": "subscription = observable.subscribe(...); subscription.dispose()"
    },
    {
      "term": "Subject",
      "definition": "Both an Observable and Observer. Can emit values and be subscribed to.",
      "category": "Core",
      "relatedTerms": ["BehaviorSubject", "ReplaySubject", "PublishSubject"],
      "example": "subject.onNext(value); subject.subscribe(observer)"
    },
    {
      "term": "BehaviorSubject",
      "definition": "A Subject that caches and replays the most recent value to new subscribers.",
      "category": "Subjects",
      "relatedTerms": ["Subject", "ReplaySubject"],
      "example": "BehaviorSubject(initialValue) replays last value on subscribe"
    },
    {
      "term": "ReplaySubject",
      "definition": "A Subject that caches and replays the last N values to new subscribers.",
      "category": "Subjects",
      "relatedTerms": ["Subject", "BehaviorSubject", "Replay"],
      "example": "ReplaySubject(bufferSize: 3) replays last 3 values"
    },
    {
      "term": "PublishSubject",
      "definition": "A Subject that only emits values after subscription. No replay of past values.",
      "category": "Subjects",
      "relatedTerms": ["Subject", "Publish"],
      "example": "PublishSubject emits only new values to subscribers"
    },
    {
      "term": "Hot Observable",
      "definition": "An Observable that emits regardless of subscribers. Values can be missed.",
      "category": "Core",
      "relatedTerms": ["Cold Observable", "Subject", "Publish"],
      "example": "Mouse events, WebSocket messages"
    },
    {
      "term": "Cold Observable",
      "definition": "An Observable that starts fresh for each subscriber. Each subscriber gets all values.",
      "category": "Core",
      "relatedTerms": ["Hot Observable", "Defer"],
      "example": "HTTP requests, database queries"
    },
    {
      "term": "Scheduler",
      "definition": "Controls when and on which thread work is performed and results are observed.",
      "category": "Core",
      "relatedTerms": ["SubscribeOn", "ObserveOn"],
      "example": "mainScheduler for UI, ioScheduler for network"
    },
    {
      "term": "Backpressure",
      "definition": "Mechanism for handling when producer is faster than consumer.",
      "category": "Advanced",
      "relatedTerms": ["Buffer", "Sample", "Debounce"],
      "example": "buffer(), sample(), debounce() help manage backpressure"
    },
    {
      "term": "Operator",
      "definition": "A function that transforms, filters, or combines Observables.",
      "category": "Core",
      "relatedTerms": ["Map", "Filter", "FlatMap"],
      "example": "stream.map(x => x * 2).filter(x => x > 10)"
    },
    {
      "term": "Map",
      "definition": "Transform each emitted value by applying a function.",
      "category": "Transformation",
      "relatedTerms": ["FlatMap", "Scan"],
      "example": "stream.map(x => x * 2) transforms 1,2,3 to 2,4,6"
    },
    {
      "term": "FlatMap",
      "definition": "Map each value to an Observable and flatten results into single stream.",
      "category": "Transformation",
      "relatedTerms": ["Map", "Switch", "ConcatMap"],
      "example": "ids.flatMap(id => fetchUser(id)) for parallel API calls"
    },
    {
      "term": "Switch",
      "definition": "Like FlatMap but cancels previous inner Observable when new value arrives.",
      "category": "Transformation",
      "relatedTerms": ["FlatMap", "ConcatMap"],
      "example": "searchText.switch(q => api.search(q)) for search-as-you-type"
    },
    {
      "term": "ConcatMap",
      "definition": "Like FlatMap but processes inner Observables sequentially in order.",
      "category": "Transformation",
      "relatedTerms": ["FlatMap", "Switch", "Concat"],
      "example": "saves.concatMap(data => api.save(data)) for ordered saves"
    },
    {
      "term": "Scan",
      "definition": "Apply accumulator function and emit each intermediate result.",
      "category": "Transformation",
      "relatedTerms": ["Reduce", "Map"],
      "example": "stream.scan((sum, x) => sum + x, 0) for running total"
    },
    {
      "term": "Reduce",
      "definition": "Apply accumulator and emit only the final result on complete.",
      "category": "Aggregate",
      "relatedTerms": ["Scan", "Count", "Sum"],
      "example": "stream.reduce((sum, x) => sum + x) emits total on complete"
    },
    {
      "term": "Filter",
      "definition": "Emit only values that pass a predicate test.",
      "category": "Filtering",
      "relatedTerms": ["Take", "Skip", "Distinct"],
      "example": "stream.filter(x => x > 0) keeps only positive values"
    },
    {
      "term": "Take",
      "definition": "Emit only the first N items, then complete.",
      "category": "Filtering",
      "relatedTerms": ["TakeLast", "TakeUntil", "TakeWhile"],
      "example": "stream.take(3) emits first 3 items then completes"
    },
    {
      "term": "TakeUntil",
      "definition": "Emit values until a notifier Observable emits, then complete.",
      "category": "Filtering",
      "relatedTerms": ["Take", "SkipUntil"],
      "example": "stream.takeUntil(destroy$) for cleanup pattern"
    },
    {
      "term": "Skip",
      "definition": "Suppress the first N items and emit the rest.",
      "category": "Filtering",
      "relatedTerms": ["SkipLast", "SkipUntil", "SkipWhile"],
      "example": "stream.skip(2) skips first 2 items"
    },
    {
      "term": "Distinct",
      "definition": "Suppress duplicate items from the sequence.",
      "category": "Filtering",
      "relatedTerms": ["Filter", "Debounce"],
      "example": "stream.distinct() removes duplicates"
    },
    {
      "term": "Debounce",
      "definition": "Emit only after a quiet period with no new emissions.",
      "category": "Filtering",
      "relatedTerms": ["Sample", "Distinct"],
      "example": "input.debounce(300.ms) waits for typing pause"
    },
    {
      "term": "Sample",
      "definition": "Emit the most recent value at periodic intervals.",
      "category": "Filtering",
      "relatedTerms": ["Debounce", "Buffer"],
      "example": "stream.sample(1.second) samples every second"
    },
    {
      "term": "Buffer",
      "definition": "Collect emissions into arrays and emit periodically or by count.",
      "category": "Transformation",
      "relatedTerms": ["Window", "Sample"],
      "example": "stream.buffer(3) collects into arrays of 3"
    },
    {
      "term": "Window",
      "definition": "Split source into sub-Observables instead of arrays.",
      "category": "Transformation",
      "relatedTerms": ["Buffer", "GroupBy"],
      "example": "stream.window(3) emits sub-Observables of 3 items"
    },
    {
      "term": "GroupBy",
      "definition": "Divide into grouped Observables organized by key.",
      "category": "Transformation",
      "relatedTerms": ["Window", "Filter"],
      "example": "users.groupBy(u => u.role) groups by role"
    },
    {
      "term": "Merge",
      "definition": "Combine multiple Observables by interleaving emissions.",
      "category": "Combination",
      "relatedTerms": ["Concat", "CombineLatest", "Zip"],
      "example": "Merge(stream1, stream2) interleaves by time"
    },
    {
      "term": "Concat",
      "definition": "Emit from streams sequentially, one after another.",
      "category": "Combination",
      "relatedTerms": ["Merge", "ConcatMap"],
      "example": "Concat(first$, second$) emits all from first, then second"
    },
    {
      "term": "CombineLatest",
      "definition": "Combine latest values from sources when any emits.",
      "category": "Combination",
      "relatedTerms": ["Zip", "Merge"],
      "example": "CombineLatest(a$, b$) for derived state"
    },
    {
      "term": "Zip",
      "definition": "Pair values from sources by index (1-to-1).",
      "category": "Combination",
      "relatedTerms": ["CombineLatest", "Merge"],
      "example": "Zip(a$, b$) pairs first with first, second with second"
    },
    {
      "term": "StartWith",
      "definition": "Prepend specified values before source emissions.",
      "category": "Combination",
      "relatedTerms": ["Concat", "DefaultIfEmpty"],
      "example": "stream.startWith(0) prepends 0"
    },
    {
      "term": "Amb",
      "definition": "Mirror the first Observable to emit, ignore others.",
      "category": "Conditional",
      "relatedTerms": ["Merge", "Race"],
      "example": "Amb(cache$, api$) uses whichever responds first"
    },
    {
      "term": "Catch",
      "definition": "Recover from errors by returning fallback value or Observable.",
      "category": "Error Handling",
      "relatedTerms": ["Retry", "Throw"],
      "example": "stream.catch(e => defaultValue) recovers from errors"
    },
    {
      "term": "Retry",
      "definition": "Resubscribe to source on error.",
      "category": "Error Handling",
      "relatedTerms": ["Catch", "Throw"],
      "example": "api.call().retry(3) retries up to 3 times"
    },
    {
      "term": "Throw",
      "definition": "Create an Observable that emits error immediately.",
      "category": "Creation",
      "relatedTerms": ["Empty", "Never", "Catch"],
      "example": "Throw(Exception('Error!')) errors immediately"
    },
    {
      "term": "Timeout",
      "definition": "Error if no emission within specified time.",
      "category": "Utility",
      "relatedTerms": ["Delay", "Timer"],
      "example": "stream.timeout(5.seconds) errors if silent too long"
    },
    {
      "term": "Delay",
      "definition": "Shift all emissions forward in time.",
      "category": "Utility",
      "relatedTerms": ["Timer", "Timeout"],
      "example": "stream.delay(500.ms) delays all emissions"
    },
    {
      "term": "Do",
      "definition": "Register side effect actions for Observable lifecycle events.",
      "category": "Utility",
      "relatedTerms": ["Subscribe", "Materialize"],
      "example": "stream.do(onNext: log, onError: logError)"
    },
    {
      "term": "Materialize",
      "definition": "Wrap emissions as Notification objects.",
      "category": "Utility",
      "relatedTerms": ["Dematerialize", "Do"],
      "example": "stream.materialize() wraps next/error/complete"
    },
    {
      "term": "Dematerialize",
      "definition": "Convert Notification objects back to emissions.",
      "category": "Utility",
      "relatedTerms": ["Materialize"],
      "example": "notifications.dematerialize() unwraps"
    },
    {
      "term": "Publish",
      "definition": "Convert to ConnectableObservable for multicasting.",
      "category": "Connectable",
      "relatedTerms": ["Connect", "RefCount", "Replay"],
      "example": "stream.publish() makes connectable"
    },
    {
      "term": "Connect",
      "definition": "Start emitting from ConnectableObservable to subscribers.",
      "category": "Connectable",
      "relatedTerms": ["Publish", "RefCount"],
      "example": "connectable.connect() starts emissions"
    },
    {
      "term": "RefCount",
      "definition": "Auto-connect on first subscriber, disconnect on last.",
      "category": "Connectable",
      "relatedTerms": ["Publish", "Connect"],
      "example": "stream.publish().refCount() auto-manages"
    },
    {
      "term": "Replay",
      "definition": "Cache and replay last N values to late subscribers.",
      "category": "Connectable",
      "relatedTerms": ["Publish", "ReplaySubject"],
      "example": "stream.replay(1) caches last value"
    },
    {
      "term": "SubscribeOn",
      "definition": "Specify which scheduler to use for subscription.",
      "category": "Utility",
      "relatedTerms": ["ObserveOn", "Scheduler"],
      "example": "stream.subscribeOn(ioScheduler) for background work"
    },
    {
      "term": "ObserveOn",
      "definition": "Specify which scheduler to observe results on.",
      "category": "Utility",
      "relatedTerms": ["SubscribeOn", "Scheduler"],
      "example": "stream.observeOn(mainScheduler) for UI updates"
    },
    {
      "term": "Just",
      "definition": "Create Observable that emits a single value and completes.",
      "category": "Creation",
      "relatedTerms": ["From", "Empty"],
      "example": "Just(42) emits 42 then completes"
    },
    {
      "term": "From",
      "definition": "Convert array/iterable to Observable.",
      "category": "Creation",
      "relatedTerms": ["Just", "Range"],
      "example": "From([1,2,3]) emits 1, 2, 3"
    },
    {
      "term": "Interval",
      "definition": "Emit sequential integers at time intervals.",
      "category": "Creation",
      "relatedTerms": ["Timer", "Range"],
      "example": "Interval(1.second) emits 0, 1, 2... every second"
    },
    {
      "term": "Timer",
      "definition": "Emit single value after delay, then complete.",
      "category": "Creation",
      "relatedTerms": ["Interval", "Delay"],
      "example": "Timer(2.seconds) emits 0 after 2 seconds"
    },
    {
      "term": "Range",
      "definition": "Emit a sequence of integers in a range.",
      "category": "Creation",
      "relatedTerms": ["From", "Interval"],
      "example": "Range(1, 5) emits 1, 2, 3, 4, 5"
    },
    {
      "term": "Empty",
      "definition": "Create Observable that completes immediately without emitting.",
      "category": "Creation",
      "relatedTerms": ["Never", "Throw"],
      "example": "Empty() completes immediately"
    },
    {
      "term": "Never",
      "definition": "Create Observable that never emits and never completes.",
      "category": "Creation",
      "relatedTerms": ["Empty", "Throw"],
      "example": "Never() sits idle forever"
    },
    {
      "term": "Defer",
      "definition": "Create fresh Observable for each subscriber.",
      "category": "Creation",
      "relatedTerms": ["Create", "Just"],
      "example": "Defer(() => Just(Date.now())) fresh timestamp each time"
    },
    {
      "term": "Create",
      "definition": "Build Observable from scratch with custom logic.",
      "category": "Creation",
      "relatedTerms": ["Defer", "Just"],
      "example": "Create(observer => { observer.next(1); observer.complete(); })"
    },
    {
      "term": "Using",
      "definition": "Create disposable resource with same lifespan as Observable.",
      "category": "Utility",
      "relatedTerms": ["Create", "Defer"],
      "example": "Using(() => resource, res => useRes(res))"
    },
    {
      "term": "To",
      "definition": "Convert Observable to other data structure.",
      "category": "Conversion",
      "relatedTerms": ["From", "Reduce"],
      "example": "stream.toList() collects all values"
    },
    {
      "term": "All",
      "definition": "Check if all items satisfy a condition.",
      "category": "Conditional",
      "relatedTerms": ["Contains", "Any"],
      "example": "stream.all(x => x > 0) true if all positive"
    },
    {
      "term": "Contains",
      "definition": "Check if Observable emits a specific value.",
      "category": "Conditional",
      "relatedTerms": ["All", "IsEmpty"],
      "example": "stream.contains(42) true if 42 is emitted"
    },
    {
      "term": "DefaultIfEmpty",
      "definition": "Emit default value if source completes empty.",
      "category": "Conditional",
      "relatedTerms": ["Empty", "StartWith"],
      "example": "stream.defaultIfEmpty(0) emits 0 if empty"
    },
    {
      "term": "SequenceEqual",
      "definition": "Check if two Observables emit same sequence.",
      "category": "Conditional",
      "relatedTerms": ["All", "Zip"],
      "example": "stream1.sequenceEqual(stream2)"
    },
    {
      "term": "Count",
      "definition": "Emit the number of items emitted by source.",
      "category": "Aggregate",
      "relatedTerms": ["Sum", "Average", "Reduce"],
      "example": "stream.count() emits total count"
    },
    {
      "term": "Sum",
      "definition": "Emit the sum of all values.",
      "category": "Aggregate",
      "relatedTerms": ["Count", "Average", "Reduce"],
      "example": "numbers.sum() emits total"
    },
    {
      "term": "Average",
      "definition": "Emit the average of all values.",
      "category": "Aggregate",
      "relatedTerms": ["Sum", "Count", "Reduce"],
      "example": "numbers.average() emits mean"
    },
    {
      "term": "Min",
      "definition": "Emit the minimum value.",
      "category": "Aggregate",
      "relatedTerms": ["Max", "Reduce"],
      "example": "numbers.min() emits smallest"
    },
    {
      "term": "Max",
      "definition": "Emit the maximum value.",
      "category": "Aggregate",
      "relatedTerms": ["Min", "Reduce"],
      "example": "numbers.max() emits largest"
    },
    {
      "term": "First",
      "definition": "Emit only the first item.",
      "category": "Filtering",
      "relatedTerms": ["Last", "Take", "Single"],
      "example": "stream.first emits first item only"
    },
    {
      "term": "Last",
      "definition": "Emit only the last item.",
      "category": "Filtering",
      "relatedTerms": ["First", "TakeLast"],
      "example": "stream.last emits last item only"
    },
    {
      "term": "Single",
      "definition": "Expect exactly one item, error otherwise.",
      "category": "Filtering",
      "relatedTerms": ["First", "Last"],
      "example": "stream.single errors if not exactly one item"
    },
    {
      "term": "ElementAt",
      "definition": "Emit only the item at specified index.",
      "category": "Filtering",
      "relatedTerms": ["First", "Last", "Take"],
      "example": "stream.elementAt(2) emits third item"
    },
    {
      "term": "IgnoreElements",
      "definition": "Ignore all items, only pass completion/error.",
      "category": "Filtering",
      "relatedTerms": ["Filter", "Take"],
      "example": "stream.ignoreElements() passes only termination"
    },
    {
      "term": "Timestamp",
      "definition": "Attach timestamp to each emitted item.",
      "category": "Utility",
      "relatedTerms": ["TimeInterval", "Delay"],
      "example": "stream.timestamp() wraps with time info"
    },
    {
      "term": "TimeInterval",
      "definition": "Emit time elapsed since previous emission.",
      "category": "Utility",
      "relatedTerms": ["Timestamp", "Delay"],
      "example": "stream.timeInterval() shows gaps"
    },
    {
      "term": "Dispose",
      "definition": "Cancel a subscription and clean up resources.",
      "category": "Core",
      "relatedTerms": ["Subscription", "Using"],
      "example": "subscription.dispose() cancels"
    },
    {
      "term": "Higher-Order Observable",
      "definition": "An Observable that emits other Observables.",
      "category": "Advanced",
      "relatedTerms": ["FlatMap", "Switch", "Concat"],
      "example": "clicks.map(c => fetchData(c)) emits Observables"
    },
    {
      "term": "Marble Diagram",
      "definition": "Visual representation of Observable behavior over time.",
      "category": "Advanced",
      "relatedTerms": ["Observable", "Operator"],
      "example": "--1--2--3--|  represents emissions over time"
    }
  ]
}
