{
  "antiPatterns": [
    {
      "title": "Forgetting to Dispose",
      "description": "Not canceling subscriptions causes memory leaks",
      "icon": "memory",
      "color": "red",
      "severity": 5,
      "relatedOperators": ["TakeUntil", "Take"],
      "tip": "Use TakeUntil(disposeSignal) pattern for automatic cleanup",
      "wrongCode": "// ❌ WRONG\nclass MyComponent {\n  onInit() {\n    stream.subscribe(data => {\n      this.data = data\n    })\n    // Subscription never cancelled!\n  }\n}",
      "rightCode": "// ✅ RIGHT\nclass MyComponent {\n  subscription = null\n  \n  onInit() {\n    subscription = stream.subscribe(...)\n  }\n  \n  onDestroy() {\n    subscription?.dispose()\n  }\n}",
      "explanation": "Uncancelled subscriptions hold references to your component, preventing garbage collection and causing memory leaks."
    },
    {
      "title": "Nested Subscriptions",
      "description": "Creating subscriptions inside subscribe callbacks",
      "icon": "layers",
      "color": "orange",
      "severity": 4,
      "relatedOperators": ["FlatMap", "Switch", "Concat"],
      "tip": "Use FlatMap family to chain dependent streams",
      "wrongCode": "// ❌ WRONG - Pyramid of doom!\nuserStream.subscribe(user => {\n  ordersStream(user.id).subscribe(orders => {\n    productsStream(orders).subscribe(products => {\n      // 3 nested subscriptions!\n    })\n  })\n})",
      "rightCode": "// ✅ RIGHT - Single flat chain\nuserStream\n  .flatMap(user => ordersStream(user.id))\n  .flatMap(orders => productsStream(orders))\n  .subscribe(products => ...)",
      "explanation": "Nested subscriptions create callback hell and are hard to manage. Use FlatMap to flatten the chain."
    },
    {
      "title": "FlatMap vs Switch Confusion",
      "description": "Using FlatMap when Switch is needed for search",
      "icon": "search",
      "color": "blue",
      "severity": 5,
      "relatedOperators": ["Switch", "FlatMap"],
      "tip": "Switch cancels previous - use for search. FlatMap keeps all - use for parallel.",
      "wrongCode": "// ❌ WRONG - Race condition!\nsearchText\n  .flatMap(q => searchApi(q))\n  .subscribe(results => {\n    // Old slow request may override new!\n  })",
      "rightCode": "// ✅ RIGHT - Previous cancelled\nsearchText\n  .switch(q => searchApi(q))\n  .subscribe(results => {\n    // Always latest query results\n  })",
      "explanation": "FlatMap keeps ALL inner subscriptions active. Switch CANCELS previous on new emission."
    },
    {
      "title": "Ignoring Errors",
      "description": "Not handling errors kills the subscription",
      "icon": "bug_report",
      "color": "red",
      "severity": 5,
      "relatedOperators": ["Catch", "Retry"],
      "tip": "Always add error handling - streams die on unhandled errors",
      "wrongCode": "// ❌ WRONG - Stream dies on first error\napiStream.subscribe(data => {\n  updateUI(data)\n})\n// After error, NOTHING works!",
      "rightCode": "// ✅ RIGHT - Handle gracefully\napiStream\n  .retry(3)\n  .catch(e => defaultValue)\n  .subscribe(data => ..., error => ...)",
      "explanation": "Unhandled errors terminate the stream permanently. Use Retry for transient failures, Catch for fallbacks."
    },
    {
      "title": "Hot vs Cold Confusion",
      "description": "Not understanding when side effects occur",
      "icon": "whatshot",
      "color": "deepOrange",
      "severity": 4,
      "relatedOperators": ["Publish", "RefCount", "Replay"],
      "tip": "Use Publish().RefCount() to share cold observables",
      "wrongCode": "// ❌ WRONG - API called 3 times!\napiData$ = api.fetch()\n\napiData$.subscribe(a)\napiData$.subscribe(b)\napiData$.subscribe(c)",
      "rightCode": "// ✅ RIGHT - API called once!\napiData$ = api.fetch()\n  .publish()\n  .refCount()\n\napiData$.subscribe(a)\napiData$.subscribe(b)\napiData$.subscribe(c)",
      "explanation": "Cold observables execute their logic for each subscriber. Use Publish with RefCount to share."
    },
    {
      "title": "Not Debouncing Input",
      "description": "Sending API request on every keystroke",
      "icon": "speed",
      "color": "amber",
      "severity": 4,
      "relatedOperators": ["Debounce", "Distinct", "Filter"],
      "tip": "Always debounce user input before API calls",
      "wrongCode": "// ❌ WRONG - API hammered!\ntextChanges.subscribe(text => {\n  api.search(text)  // Every character!\n})",
      "rightCode": "// ✅ RIGHT - Optimized\ntextChanges\n  .debounce(300.ms)\n  .distinct()\n  .filter(t => t.length >= 2)\n  .flatMap(t => api.search(t))\n  .subscribe(showResults)",
      "explanation": "Debounce waits for typing pause. Distinct prevents duplicate searches. Filter ignores short queries."
    },
    {
      "title": "Imperative Logic in Streams",
      "description": "Using if/else/loops inside operators",
      "icon": "psychology",
      "color": "blue",
      "severity": 3,
      "relatedOperators": ["Filter", "Map"],
      "tip": "Use Filter() instead of if, Map() instead of modifications",
      "wrongCode": "// ❌ WRONG - Imperative in stream\nstream.subscribe(value => {\n  if (value > 10) {\n    result = value * 2\n    updateUI(result)\n  }\n})",
      "rightCode": "// ✅ RIGHT - Declarative\nstream\n  .filter(value => value > 10)\n  .map(value => value * 2)\n  .subscribe(updateUI)",
      "explanation": "Rx is declarative. Push logic into operators for composable, testable, reusable code."
    },
    {
      "title": "Not Sharing Side Effects",
      "description": "Multiple subscriptions cause duplicate side effects",
      "icon": "layers",
      "color": "purple",
      "severity": 4,
      "relatedOperators": ["Publish", "RefCount", "Replay"],
      "tip": "Publish().RefCount() when multiple consumers need the same stream",
      "wrongCode": "// ❌ WRONG - Log fires twice!\napiStream = fetch().do(log)\n\napiStream.subscribe(updateList)\napiStream.subscribe(updateCount)",
      "rightCode": "// ✅ RIGHT - Shared stream\napiStream = fetch().do(log)\n  .publish()\n  .refCount()\n\napiStream.subscribe(updateList)\napiStream.subscribe(updateCount)",
      "explanation": "Without sharing, each subscription is independent, causing duplicate side effects."
    },
    {
      "title": "Sync Subscribe for Async Data",
      "description": "Expecting immediate values from async streams",
      "icon": "hourglass_empty",
      "color": "deepOrange",
      "severity": 4,
      "relatedOperators": ["First", "To"],
      "tip": "Use async/await or handle values reactively",
      "wrongCode": "// ❌ WRONG - result is undefined!\nresult = null\nasyncStream.subscribe(v => result = v)\nprint(result)  // Still null!",
      "rightCode": "// ✅ RIGHT - Handle async\nasyncStream.subscribe(result => {\n  print(result)  // Value is here\n})\n// Or: result = await asyncStream.first",
      "explanation": "Subscriptions deliver values asynchronously. Handle values in the callback or use async/await."
    },
    {
      "title": "Forgetting Distinct",
      "description": "Processing duplicate consecutive values",
      "icon": "sync",
      "color": "orange",
      "severity": 3,
      "relatedOperators": ["Distinct"],
      "tip": "Add Distinct before expensive operations",
      "wrongCode": "// ❌ WRONG - Redundant API calls\nselectedId\n  .flatMap(id => fetchDetails(id))\n  .subscribe(showDetails)",
      "rightCode": "// ✅ RIGHT - Skip duplicates\nselectedId\n  .distinct()\n  .flatMap(id => fetchDetails(id))\n  .subscribe(showDetails)",
      "explanation": "Without Distinct, consecutive equal values trigger redundant operations."
    },
    {
      "title": "Breaking the Chain",
      "description": "Assigning intermediate results to variables",
      "icon": "code",
      "color": "blue",
      "severity": 2,
      "relatedOperators": [],
      "tip": "Keep the chain flowing, extract to functions if needed",
      "wrongCode": "// ❌ WRONG - Broken chain\nfiltered = stream.filter(x => x > 0)\nmapped = filtered.map(x => x * 2)\nmapped.subscribe(handle)",
      "rightCode": "// ✅ RIGHT - Continuous chain\nstream\n  .filter(x => x > 0)\n  .map(x => x * 2)\n  .subscribe(handle)",
      "explanation": "Breaking chains makes code harder to read and reason about. Keep operators chained."
    },
    {
      "title": "Using Subjects as APIs",
      "description": "Exposing Subjects publicly instead of Observables",
      "icon": "error_outline",
      "color": "red",
      "severity": 4,
      "relatedOperators": ["Publish"],
      "tip": "Expose .asObservable() to prevent external emissions",
      "wrongCode": "// ❌ WRONG - Anyone can emit!\nclass UserService {\n  currentUser$ = new BehaviorSubject()\n}\n// External: userService.currentUser$.next(malicious)",
      "rightCode": "// ✅ RIGHT - Read-only public API\nclass UserService {\n  _currentUser = new BehaviorSubject()\n  currentUser$ = _currentUser.asObservable()\n}",
      "explanation": "Exposing Subjects allows external code to emit values, breaking encapsulation."
    },
    {
      "title": "Creating Observables in Subscribe",
      "description": "Recreating streams inside callbacks",
      "icon": "memory",
      "color": "teal",
      "severity": 4,
      "relatedOperators": ["FlatMap", "Switch"],
      "tip": "Create streams once, combine with operators",
      "wrongCode": "// ❌ WRONG - New stream each time\nclicks.subscribe(_ => {\n  Observable.interval(1.second)\n    .subscribe(tick => handle(tick))\n})",
      "rightCode": "// ✅ RIGHT - Combined properly\nclicks\n  .flatMap(_ => Observable.interval(1.second))\n  .subscribe(tick => handle(tick))",
      "explanation": "Creating Observables inside subscribe leads to memory leaks and untracked subscriptions."
    },
    {
      "title": "Ignoring Concurrency",
      "description": "Not considering parallel execution behavior",
      "icon": "speed",
      "color": "purple",
      "severity": 3,
      "relatedOperators": ["FlatMap", "Concat", "Switch"],
      "tip": "FlatMap(n) limits concurrent inner subscriptions",
      "wrongCode": "// ❌ WRONG - 1000 parallel requests!\nids.from(largeArray)\n  .flatMap(id => api.fetch(id))\n  .subscribe()",
      "rightCode": "// ✅ RIGHT - Limited concurrency\nids.from(largeArray)\n  .flatMap(id => api.fetch(id), 5)  // Max 5 parallel\n  .subscribe()",
      "explanation": "Unbounded FlatMap can overwhelm servers with parallel requests. Limit concurrency."
    },
    {
      "title": "Not Testing Rx Code",
      "description": "Skipping tests for reactive flows",
      "icon": "search",
      "color": "teal",
      "severity": 3,
      "relatedOperators": [],
      "tip": "Use TestScheduler for deterministic time control",
      "wrongCode": "// ❌ WRONG - No tests\nautoSave$ = textChanges$\n  .debounce(2.seconds)\n  .flatMap(text => api.save(text))",
      "rightCode": "// ✅ RIGHT - Tested with virtual time\ntestScheduler.run(({ cold, expectObservable }) => {\n  const input = cold('a-b-c---d|')\n  const expected = '-------c---d|'\n  expectObservable(input.debounce(30, scheduler)).toBe(expected)\n})",
      "explanation": "Rx code involves timing and async behavior. Use TestScheduler for reliable tests."
    },
    {
      "title": "Overcomplicating Simple Tasks",
      "description": "Using Rx when simple code would suffice",
      "icon": "psychology",
      "color": "amber",
      "severity": 2,
      "relatedOperators": [],
      "tip": "Not everything needs to be a stream",
      "wrongCode": "// ❌ WRONG - Over-engineered\nObservable.just(2)\n  .map(x => x + 3)\n  .subscribe(result => print(result))",
      "rightCode": "// ✅ RIGHT - Simple is better\nresult = 2 + 3\nprint(result)",
      "explanation": "Rx adds complexity. Use it for async/event-driven scenarios, not simple synchronous code."
    },
    {
      "title": "Mixing Rx with Imperative State",
      "description": "Mutating shared state from within stream operators",
      "icon": "error_outline",
      "color": "red",
      "severity": 5,
      "relatedOperators": ["Scan"],
      "tip": "Use Scan for state, keep operators pure",
      "wrongCode": "// ❌ WRONG - Shared mutable state!\nlet count = 0\nclicks.subscribe(_ => {\n  count++  // Race conditions!\n  updateUI(count)\n})",
      "rightCode": "// ✅ RIGHT - State in stream\nclicks\n  .scan((count, _) => count + 1, 0)\n  .subscribe(count => updateUI(count))",
      "explanation": "Mutating external state from streams causes race conditions and unpredictable behavior."
    },
    {
      "title": "Using Wrong Scheduler",
      "description": "Blocking main thread with heavy computation",
      "icon": "speed",
      "color": "orange",
      "severity": 4,
      "relatedOperators": ["SubscribeOn", "ObserveOn"],
      "tip": "Use SubscribeOn for work, ObserveOn for results",
      "wrongCode": "// ❌ WRONG - Heavy work on main thread\ndata$.map(d => heavyComputation(d))\n  .subscribe(result => updateUI(result))",
      "rightCode": "// ✅ RIGHT - Work on background\ndata$\n  .subscribeOn(backgroundScheduler)\n  .map(d => heavyComputation(d))\n  .observeOn(mainScheduler)\n  .subscribe(result => updateUI(result))",
      "explanation": "Heavy computation on main thread causes UI freezes. Use schedulers appropriately."
    },
    {
      "title": "Incomplete Error Recovery",
      "description": "Catching errors but not restarting the stream",
      "icon": "healing",
      "color": "red",
      "severity": 4,
      "relatedOperators": ["Catch", "Retry"],
      "tip": "Use Retry for transient errors, Catch for fallback",
      "wrongCode": "// ❌ WRONG - Stream dead after first error\nwebsocket$\n  .catch(e => empty())\n  .subscribe(msg => handle(msg))",
      "rightCode": "// ✅ RIGHT - Auto-reconnect\nwebsocket$\n  .retry()\n  .catch(e => {\n    logError(e)\n    return websocket$  // Restart!\n  })\n  .subscribe(msg => handle(msg))",
      "explanation": "Catching to empty terminates the stream. Use Retry or restart for long-lived streams."
    },
    {
      "title": "Not Completing Subjects",
      "description": "Forgetting to complete Subjects on cleanup",
      "icon": "memory",
      "color": "purple",
      "severity": 3,
      "relatedOperators": [],
      "tip": "Always call complete() on Subjects when done",
      "wrongCode": "// ❌ WRONG - Subject left open\nclass MyComponent {\n  destroy$ = new Subject()\n  \n  onDestroy() {\n    destroy$.next()  // Emits signal\n    // But never completed!\n  }\n}",
      "rightCode": "// ✅ RIGHT - Properly completed\nclass MyComponent {\n  destroy$ = new Subject()\n  \n  onDestroy() {\n    destroy$.next()\n    destroy$.complete()  // Clean up!\n  }\n}",
      "explanation": "Uncompleted Subjects may retain references and prevent garbage collection."
    }
  ]
}
